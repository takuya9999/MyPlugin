import pymel.core as pm
import maya.cmds as mc
import maya.app.type.typeToolSetup as tt
from decimal import *

div=''
count = 0

def getSpacedHexFromString(text):
    hexVersion = ""
    for i in range(0,len(text)):
        character = text[i:i+1] 
        hexCharacter = character.encode('hex')
        hexVersion = hexVersion + " " + hexCharacter   
    return hexVersion

def setText(ctl='',divNum=''):
    print 'せんきゅー！せんきゅー！',ctl,divNum
    # text = getSpacedHexFromString(pm.getAttr(ctlDiv))
    # pm.setAttr("%s.textInput" % divNum,text)

def getCurve():
    getcontext().prec = 5
    shp = mc.listRelatives(mc.ls(sl=1)[0],s=1)[0]
    cvs = mc.getAttr(shp+'.cv[*]')
    cvsSimple = []
    for c in cvs:
        cvsSimple.append([float(Decimal("%.3f" % c[0])),float(Decimal("%.3f" % c[1])),float(Decimal("%.3f" % c[2]))])


    out = '\n\n### run python: #################\n\nimport maya.cmds as mc\nmc.curve(p='  
    out += '[%s]' % ', '.join(map(str, cvsSimple))
    out += ',d='+str(mc.getAttr(shp+'.degree'))+')\n\n#################################'
    print out

def generateCurve(currentSel):




    curvelist = []
    d_outline_char = mc.curve(p=[[-1.244, 1.613, 0.0], [-1.195, 1.613, 0.0], [-1.195, 2.011, 0.0], [-1.244, 2.011, 0.0], [-1.244, 1.856, 0.0], [-1.261, 1.872, 0.0], [-1.271, 1.878, 0.0], [-1.281, 1.884, 0.0], [-1.291, 1.888, 0.0], [-1.302, 1.891, 0.0], [-1.313, 1.892, 0.0], [-1.325, 1.893, 0.0], [-1.338, 1.892, 0.0], [-1.35, 1.89, 0.0], [-1.362, 1.887, 0.0], [-1.373, 1.883, 0.0], [-1.383, 1.877, 0.0], [-1.393, 1.87, 0.0], [-1.402, 1.861, 0.0], [-1.41, 1.851, 0.0], [-1.418, 1.84, 0.0], [-1.424, 1.829, 0.0], [-1.43, 1.816, 0.0], [-1.434, 1.803, 0.0], [-1.438, 1.789, 0.0], [-1.44, 1.774, 0.0], [-1.442, 1.758, 0.0], [-1.442, 1.741, 0.0], [-1.441, 1.712, 0.0], [-1.435, 1.685, 0.0], [-1.426, 1.662, 0.0], [-1.414, 1.642, 0.0], [-1.398, 1.627, 0.0], [-1.39, 1.62, 0.0], [-1.38, 1.615, 0.0], [-1.37, 1.611, 0.0], [-1.359, 1.609, 0.0], [-1.348, 1.607, 0.0], [-1.336, 1.606, 0.0], [-1.321, 1.607, 0.0], [-1.307, 1.61, 0.0], [-1.294, 1.614, 0.0], [-1.282, 1.621, 0.0], [-1.271, 1.629, 0.0], [-1.261, 1.639, 0.0], [-1.252, 1.651, 0.0], [-1.244, 1.664, 0.0], [-1.244, 1.613, 0.0]],d=1)
    d_inline_char = mc.curve(p=[[-1.244, 1.821, 0.0], [-1.244, 1.695, 0.0], [-1.264, 1.675, 0.0], [-1.285, 1.661, 0.0], [-1.295, 1.656, 0.0], [-1.305, 1.653, 0.0], [-1.315, 1.651, 0.0], [-1.326, 1.65, 0.0], [-1.341, 1.651, 0.0], [-1.353, 1.656, 0.0], [-1.364, 1.664, 0.0], [-1.373, 1.674, 0.0], [-1.38, 1.688, 0.0], [-1.385, 1.704, 0.0], [-1.388, 1.724, 0.0], [-1.389, 1.746, 0.0], [-1.388, 1.771, 0.0], [-1.385, 1.793, 0.0], [-1.379, 1.811, 0.0], [-1.371, 1.827, 0.0], [-1.36, 1.84, 0.0], [-1.348, 1.848, 0.0], [-1.334, 1.854, 0.0], [-1.318, 1.856, 0.0], [-1.309, 1.855, 0.0], [-1.3, 1.853, 0.0], [-1.282, 1.847, 0.0], [-1.263, 1.836, 0.0], [-1.244, 1.821, 0.0]],d=1)
    i_top_char = mc.curve(p=[[-1.095, 1.937, 0.0], [-1.045, 1.937, 0.0], [-1.045, 1.986, 0.0], [-1.095, 1.986, 0.0], [-1.095, 1.937, 0.0]],d=1)
    i_bottom_char = mc.curve(p=[[-1.095, 1.613, 0.0], [-1.045, 1.613, 0.0], [-1.045, 1.887, 0.0], [-1.095, 1.887, 0.0], [-1.095, 1.613, 0.0]],d=1)
    v_char = mc.curve(p=[[-0.888, 1.613, 0.0], [-0.838, 1.613, 0.0], [-0.73, 1.887, 0.0], [-0.776, 1.887, 0.0], [-0.86, 1.674, 0.0], [-0.94, 1.887, 0.0], [-0.99, 1.887, 0.0], [-0.888, 1.613, 0.0]],d=1)
    sliderFIeld = mc.curve(p=[[-1.428, 1.546, 0.047], [-1.428, 0.998, 0.047], [0.133, 0.998, 0.047], [0.133, 1.546, 0.047], [-1.428, 1.546, 0.047]],d=1)
    slider = mc.curve(p=[[-1.39, 1.5, 0.047], [-1.39, 1.043, 0.047], [-1.133, 1.043, 0.047], [-1.133, 1.5, 0.047], [-1.39, 1.5, 0.047]],d=1)
    line = mc.curve(p=[[0.0, 0.998, 0.0], [0.0, -0.0, 0.0]],d=1)
    

    curvelist.append(d_outline_char)
    curvelist.append(d_inline_char)
    curvelist.append(i_top_char)
    curvelist.append(i_bottom_char)
    curvelist.append(v_char)
    curvelist.append(sliderFIeld)
    curvelist.append(slider)
    curvelist.append(line)


    sBbox = pm.exactWorldBoundingBox(currentSel)
    sBboxP =  [(sBbox[0] + sBbox[3])/2, sBbox[4], (sBbox[2] + sBbox[5])/2]
    pm.xform(slider,cp=True)	
    smoothParentGroup = pm.group(curvelist,n=currentSel+'_smooth_Ctrl')
    smoothParentGroup.scalePivot.set([0,0,0])
    smoothParentGroup.rotatePivot.set([0,0,0])
    pm.xform(smoothParentGroup,t=sBboxP)

    # one_char = mc.curve(p=[[3.469, 2.835, 0.0], [3.519, 2.835, 0.0], [3.519, 3.212, 0.0], [3.41, 3.202, 0.0], [3.41, 3.171, 0.0], [3.469, 3.171, 0.0],[3.469, 2.835, 0.0]],d=1)
    # two_chara = mc.curve(p=[[3.622, 2.835, 0.0], [3.844, 2.835, 0.0], [3.844, 2.878, 0.0], [3.682, 2.878, 0.0], [3.685, 2.89, 0.0], [3.69, 2.902, 0.0], [3.696, 2.914, 0.0], [3.704, 2.926, 0.0], [3.724, 2.95, 0.0], [3.751, 2.975, 0.0], [3.77, 2.992, 0.0], [3.791, 3.01, 0.0], [3.807, 3.026, 0.0], [3.82, 3.041, 0.0], [3.83, 3.055, 0.0], [3.837, 3.068, 0.0], [3.842, 3.083, 0.0], [3.845, 3.098, 0.0], [3.846, 3.114, 0.0], [3.846, 3.126, 0.0], [3.844, 3.137, 0.0], [3.838, 3.157, 0.0], [3.828, 3.174, 0.0], [3.815, 3.189, 0.0], [3.797, 3.202, 0.0], [3.778, 3.211, 0.0], [3.755, 3.216, 0.0], [3.73, 3.218, 0.0], [3.706, 3.216, 0.0], [3.681, 3.212, 0.0], [3.656, 3.205, 0.0], [3.631, 3.194, 0.0], [3.631, 3.151, 0.0], [3.657, 3.164, 0.0], [3.68, 3.173, 0.0], [3.702, 3.179, 0.0], [3.723, 3.18, 0.0], [3.738, 3.179, 0.0], [3.752, 3.176, 0.0], [3.764, 3.17, 0.0], [3.774, 3.162, 0.0], [3.783, 3.153, 0.0], [3.788, 3.141, 0.0], [3.792, 3.128, 0.0], [3.793, 3.113, 0.0], [3.792, 3.101, 0.0], [3.79, 3.089, 0.0], [3.785, 3.076, 0.0], [3.779, 3.064, 0.0], [3.772, 3.052, 0.0], [3.762, 3.039, 0.0], [3.738, 3.014, 0.0], [3.71, 2.989, 0.0], [3.679, 2.96, 0.0], [3.655, 2.931, 0.0], [3.636, 2.904, 0.0], [3.622, 2.878, 0.0],[3.622, 2.835, 0.0]],d=1)
    # three_chara = mc.curve(p=[[3.632, 2.837, 0.0], [3.657, 2.832, 0.0], [3.68, 2.828, 0.0], [3.7, 2.826, 0.0], [3.719, 2.825, 0.0], [3.734, 2.826, 0.0], [3.748, 2.827, 0.0], [3.761, 2.829, 0.0], [3.773, 2.833, 0.0], [3.796, 2.842, 0.0], [3.815, 2.855, 0.0], [3.83, 2.872, 0.0], [3.836, 2.881, 0.0], [3.841, 2.891, 0.0], [3.845, 2.902, 0.0], [3.847, 2.913, 0.0], [3.849, 2.925, 0.0], [3.85, 2.938, 0.0], [3.848, 2.957, 0.0], [3.844, 2.974, 0.0], [3.837, 2.989, 0.0], [3.827, 3.002, 0.0], [3.814, 3.014, 0.0], [3.799, 3.023, 0.0], [3.78, 3.031, 0.0], [3.759, 3.037, 0.0], [3.777, 3.045, 0.0], [3.793, 3.054, 0.0], [3.807, 3.064, 0.0], [3.818, 3.075, 0.0], [3.826, 3.087, 0.0], [3.832, 3.101, 0.0], [3.836, 3.115, 0.0], [3.837, 3.131, 0.0], [3.835, 3.151, 0.0], [3.83, 3.168, 0.0], [3.82, 3.183, 0.0], [3.807, 3.196, 0.0], [3.791, 3.205, 0.0], [3.771, 3.212, 0.0], [3.748, 3.216, 0.0], [3.722, 3.218, 0.0], [3.701, 3.217, 0.0], [3.68, 3.214, 0.0], [3.658, 3.209, 0.0], [3.637, 3.203, 0.0], [3.637, 3.159, 0.0], [3.659, 3.168, 0.0], [3.68, 3.175, 0.0], [3.7, 3.179, 0.0], [3.719, 3.18, 0.0], [3.735, 3.179, 0.0], [3.749, 3.177, 0.0], [3.76, 3.172, 0.0], [3.77, 3.166, 0.0], [3.778, 3.158, 0.0], [3.783, 3.148, 0.0], [3.786, 3.136, 0.0], [3.787, 3.123, 0.0], [3.786, 3.106, 0.0], [3.781, 3.091, 0.0], [3.773, 3.079, 0.0], [3.761, 3.068, 0.0], [3.747, 3.06, 0.0], [3.729, 3.055, 0.0], [3.708, 3.051, 0.0], [3.684, 3.05, 0.0], [3.666, 3.05, 0.0], [3.666, 3.016, 0.0], [3.686, 3.016, 0.0], [3.712, 3.015, 0.0], [3.734, 3.012, 0.0], [3.753, 3.005, 0.0], [3.769, 2.997, 0.0], [3.781, 2.986, 0.0], [3.79, 2.972, 0.0], [3.795, 2.956, 0.0], [3.796, 2.938, 0.0], [3.795, 2.922, 0.0], [3.791, 2.907, 0.0], [3.784, 2.895, 0.0], [3.774, 2.883, 0.0], [3.762, 2.874, 0.0], [3.748, 2.868, 0.0], [3.733, 2.864, 0.0], [3.716, 2.863, 0.0], [3.699, 2.864, 0.0], [3.679, 2.868, 0.0], [3.657, 2.875, 0.0], [3.632, 2.884, 0.0],[3.632, 2.837, 0.0]],d=1)
    # four_out_chara = mc.curve(p=[[3.774, 2.835, 0.0], [3.82, 2.835, 0.0], [3.82, 2.94, 0.0], [3.87, 2.94, 0.0], [3.87, 2.981, 0.0], [3.82, 2.981, 0.0], [3.82, 3.208, 0.0], [3.774, 3.208, 0.0], [3.606, 2.978, 0.0], [3.606, 2.94, 0.0], [3.774, 2.94, 0.0],[3.774, 2.835, 0.0]],d=1)
    # four_in_chara = mc.curve(p=[[3.654, 2.981, 0.0], [3.777, 3.147, 0.0], [3.777, 2.981, 0.0],[3.654, 2.981, 0.0]],d=1)
    # zero_out_chara = mc.curve(p=[[3.743, 2.825, 0.0], [3.757, 2.826, 0.0], [3.771, 2.829, 0.0], [3.784, 2.833, 0.0], [3.796, 2.839, 0.0], [3.807, 2.846, 0.0], [3.818, 2.856, 0.0], [3.828, 2.867, 0.0], [3.838, 2.879, 0.0], [3.846, 2.893, 0.0], [3.853, 2.908, 0.0], [3.859, 2.924, 0.0], [3.865, 2.942, 0.0], [3.868, 2.96, 0.0], [3.871, 2.979, 0.0], [3.873, 3.0, 0.0], [3.874, 3.022, 0.0], [3.873, 3.043, 0.0], [3.871, 3.064, 0.0], [3.868, 3.083, 0.0], [3.865, 3.101, 0.0], [3.859, 3.119, 0.0], [3.853, 3.135, 0.0], [3.846, 3.15, 0.0], [3.838, 3.164, 0.0], [3.828, 3.177, 0.0], [3.818, 3.187, 0.0], [3.807, 3.197, 0.0], [3.796, 3.204, 0.0], [3.784, 3.21, 0.0], [3.771, 3.214, 0.0], [3.757, 3.217, 0.0], [3.743, 3.218, 0.0], [3.728, 3.217, 0.0], [3.715, 3.214, 0.0], [3.702, 3.21, 0.0], [3.69, 3.204, 0.0], [3.678, 3.197, 0.0], [3.667, 3.187, 0.0], [3.657, 3.176, 0.0], [3.648, 3.164, 0.0], [3.639, 3.15, 0.0], [3.632, 3.135, 0.0], [3.626, 3.119, 0.0], [3.621, 3.101, 0.0], [3.617, 3.083, 0.0], [3.614, 3.064, 0.0], [3.612, 3.043, 0.0], [3.612, 3.022, 0.0], [3.612, 3.0, 0.0], [3.614, 2.979, 0.0], [3.617, 2.96, 0.0], [3.621, 2.942, 0.0], [3.626, 2.924, 0.0], [3.632, 2.908, 0.0], [3.639, 2.893, 0.0], [3.648, 2.879, 0.0], [3.657, 2.867, 0.0], [3.667, 2.856, 0.0], [3.678, 2.846, 0.0], [3.69, 2.839, 0.0], [3.702, 2.833, 0.0], [3.715, 2.829, 0.0], [3.728, 2.826, 0.0],[3.743, 2.825, 0.0]],d=1)
    # zero_in_chara = mc.curve(p=[[3.743, 2.863, 0.0], [3.733, 2.863, 0.0], [3.724, 2.865, 0.0], [3.716, 2.868, 0.0], [3.709, 2.873, 0.0], [3.702, 2.878, 0.0], [3.695, 2.885, 0.0], [3.684, 2.902, 0.0], [3.676, 2.925, 0.0], [3.67, 2.952, 0.0], [3.666, 2.984, 0.0], [3.665, 3.022, 0.0], [3.666, 3.059, 0.0], [3.67, 3.091, 0.0], [3.676, 3.118, 0.0], [3.684, 3.141, 0.0], [3.695, 3.158, 0.0], [3.702, 3.165, 0.0], [3.709, 3.17, 0.0], [3.716, 3.175, 0.0], [3.724, 3.178, 0.0], [3.733, 3.18, 0.0], [3.743, 3.18, 0.0], [3.752, 3.18, 0.0], [3.761, 3.178, 0.0], [3.769, 3.175, 0.0], [3.777, 3.17, 0.0], [3.784, 3.165, 0.0], [3.79, 3.158, 0.0], [3.801, 3.141, 0.0], [3.81, 3.118, 0.0], [3.816, 3.091, 0.0], [3.819, 3.059, 0.0], [3.82, 3.022, 0.0], [3.819, 2.984, 0.0], [3.816, 2.952, 0.0], [3.81, 2.925, 0.0], [3.801, 2.902, 0.0], [3.79, 2.885, 0.0], [3.784, 2.878, 0.0], [3.777, 2.873, 0.0], [3.769, 2.868, 0.0], [3.761, 2.865, 0.0], [3.752, 2.863, 0.0],[3.743, 2.863, 0.0]],d=1)
    return [slider,sliderFIeld]

def generateChildCurve(currentSel):
    curvelist = []
    d_outline_char = mc.curve(p=[[-0.384, 1.094, 0.0], [-0.335, 1.094, 0.0], [-0.335, 1.492, 0.0], [-0.384, 1.492, 0.0], [-0.384, 1.337, 0.0], [-0.401, 1.353, 0.0], [-0.411, 1.359, 0.0], [-0.421, 1.365, 0.0], [-0.431, 1.369, 0.0], [-0.442, 1.372, 0.0], [-0.453, 1.373, 0.0], [-0.465, 1.374, 0.0], [-0.478, 1.373, 0.0], [-0.49, 1.371, 0.0], [-0.502, 1.368, 0.0], [-0.513, 1.364, 0.0], [-0.523, 1.358, 0.0], [-0.533, 1.351, 0.0], [-0.542, 1.342, 0.0], [-0.55, 1.332, 0.0], [-0.558, 1.321, 0.0], [-0.564, 1.31, 0.0], [-0.57, 1.297, 0.0], [-0.574, 1.284, 0.0], [-0.578, 1.27, 0.0], [-0.58, 1.255, 0.0], [-0.582, 1.239, 0.0], [-0.582, 1.222, 0.0], [-0.581, 1.193, 0.0], [-0.575, 1.166, 0.0], [-0.566, 1.143, 0.0], [-0.554, 1.123, 0.0], [-0.538, 1.108, 0.0], [-0.53, 1.101, 0.0], [-0.52, 1.096, 0.0], [-0.51, 1.092, 0.0], [-0.499, 1.09, 0.0], [-0.488, 1.088, 0.0], [-0.476, 1.087, 0.0], [-0.461, 1.088, 0.0], [-0.447, 1.091, 0.0], [-0.434, 1.095, 0.0], [-0.422, 1.102, 0.0], [-0.411, 1.11, 0.0], [-0.401, 1.12, 0.0], [-0.392, 1.132, 0.0], [-0.384, 1.145, 0.0], [-0.384, 1.094, 0.0]],d=1)
    d_inline_char = mc.curve(p=[[-0.384, 1.302, 0.0], [-0.384, 1.176, 0.0], [-0.404, 1.156, 0.0], [-0.425, 1.142, 0.0], [-0.435, 1.137, 0.0], [-0.445, 1.134, 0.0], [-0.455, 1.132, 0.0], [-0.466, 1.131, 0.0], [-0.481, 1.132, 0.0], [-0.493, 1.137, 0.0], [-0.504, 1.145, 0.0], [-0.513, 1.155, 0.0], [-0.52, 1.169, 0.0], [-0.525, 1.185, 0.0], [-0.528, 1.205, 0.0], [-0.529, 1.227, 0.0], [-0.528, 1.252, 0.0], [-0.525, 1.274, 0.0], [-0.519, 1.292, 0.0], [-0.511, 1.308, 0.0], [-0.5, 1.321, 0.0], [-0.488, 1.329, 0.0], [-0.474, 1.335, 0.0], [-0.458, 1.337, 0.0], [-0.449, 1.336, 0.0], [-0.44, 1.334, 0.0], [-0.422, 1.328, 0.0], [-0.403, 1.317, 0.0], [-0.384, 1.302, 0.0]],d=1)
    i_top_char = mc.curve(p=[[-0.235, 1.418, 0.0], [-0.185, 1.418, 0.0], [-0.185, 1.467, 0.0], [-0.235, 1.467, 0.0], [-0.235, 1.418, 0.0]],d=1)
    i_bottom_char = mc.curve(p=[[-0.235, 1.094, 0.0], [-0.185, 1.094, 0.0], [-0.185, 1.368, 0.0], [-0.235, 1.368, 0.0], [-0.235, 1.094, 0.0]],d=1)
    v_char = mc.curve(p=[[-0.028, 1.094, 0.0], [0.022, 1.094, 0.0], [0.13, 1.368, 0.0], [0.084, 1.368, 0.0], [0.0, 1.155, 0.0], [-0.08, 1.368, 0.0], [-0.13, 1.368, 0.0], [-0.028, 1.094, 0.0]],d=1)
    line = mc.curve(p=[[0.0, 0.998, 0.0], [0.0, -0.0, 0.0]],d=1)

    curvelist.append(d_outline_char)
    curvelist.append(d_inline_char)
    curvelist.append(i_top_char)
    curvelist.append(i_bottom_char)
    curvelist.append(v_char)
    curvelist.append(line)

    sBbox = pm.exactWorldBoundingBox(currentSel)
    sBboxP =  [(sBbox[0] + sBbox[3])/2, sBbox[4], (sBbox[2] + sBbox[5])/2]
    smoothParentGroup = pm.group(curvelist,n=currentSel+'_smooth')
    smoothParentGroup.scalePivot.set([0,0,0])
    smoothParentGroup.rotatePivot.set([0,0,0])
    pm.xform(smoothParentGroup,t=sBboxP)
#複数オブジェクトにスムースをかけ、分割数をコントローラで一括制御できるようにする。
def connectSmoothAttr():
    sel = pm.selected()
    objs = sel[0:]
    cruveGen = generateCurve(sel[-1])
    slider = cruveGen[0]
    sliderField = cruveGen[1]
    ctl = sliderField

    for currentSel in (sel[:-1]):
        generateChildCurve(currentSel)
    # ctl = sel[-1] #[-1]で要素の末尾を取得
    #新しいアトリビュートを作成する
    pm.addAttr( ctl, ln='divisions',nn='div',at='long',min=0,max=4,dv=0)
    #作成したアトリビュートの編集を有効可する
    ctlDiv = pm.Attribute( ctl+'.divisions') 
    pm.setAttr( ctlDiv,e=True,keyable=True,)
    # divNum = createType(0)
    # ctlDiv >>  divNum.textInput
    # print 'どーやったらーとレンダー！',pm.getAttr("%s.textInput" % divNum)
    for obj in objs:
        smthChk=False
        for cnct in set( obj.getShape().inputs()):
            if isinstance(cnct, pm.nt.PolySmoothFace): #セットでinputsノードの重複を無くし、cnctの方がpolysmoothfaceだった場合（すでにスムースノードがある場合）はsmthckをtrueにする
                smthChk = True
                break
        if smthChk:
            ctlDiv >> cnct.divisions #すでにスムースノードがある場合は、それをctlDivアトリビュートと接続
            continue #すでにスムースノードがある場合、以降の処理をスキップ
        smthNode = pm.polySmooth(obj) #objに新しくスムースを追加し
        ctlDiv >> smthNode[0].divisions #スムースノードのdivisionsアトリビュートとctlのdivisionアトリビュート(ctlDiv)をつなぐ
    
    pm.transformLimits(slider,tx=(0,1.23),etx=(True,True))
    pm.setDrivenKeyframe("%s.divisions" % ctl,cd = "%s.tx" % slider,dv=0,v=0)
    pm.setDrivenKeyframe("%s.divisions" % ctl,cd = "%s.tx" % slider,dv=1.23,v=4)
    # pm.scriptJob(attributeChange = (ctlDiv,'setText('+ctlDiv+','+divNum+')'),parent=smooth )
    # pm.scriptJob(attributeChange = (ctlDiv,'setText('+str(ctl)+','+ str(divNum)+')'),parent=smooth )
    # pm.scriptJob(attributeChange = (ctlDiv,'setText(ctlDiv,divNum)'),parent=smooth )
    # pm.scriptJob(attributeChange = (ctlDiv,'getmessage()'),parent=smooth )
    
    # pm.setDrivenKeyframe("%s.textInput" % divNum,cd = "%s.tx" % slider,dv=0,v=getSpacedHexFromString(str(0)))
    # pm.setDrivenKeyframe("%s.textInput" % divNum,cd = "%s.tx" % slider,dv=1.23,v=getSpacedHexFromString(str(4)))

def createType(num):
    # pm.curve(d=3,p=[(-10, 0, 0),(-6, 0, 10),(-3, 0, -10),(10, 0, 0)],k=[0, 0, 0, 1, 1, 1])
    # tu.flipTypeManipulator()
    #typeオブジェクトの設定
    # global div
    divNum = tt.createTypeTool()
    # selectObj = pm.selected(div)[len(pm.selected())-1]
    # select = div.getType()
    # print selectType
    numEncode = getSpacedHexFromString(str(num))
    # text = pm.getAttr("%s.textInput" % div)
    # text2 = pm.setAttr("%s.textInput" % div,test.encode('ascii'))
    pm.setAttr("%s.fontSize" % divNum,5)
    pm.setAttr("%s.textInput" % divNum,numEncode)
    # pm.setAttr("%s.typeExtrude1.enableExtrusion" % div,0)
    # text = pm.getAttr(div.textInput)
    return divNum

def getmessage():
    print 'せんきゅー！'


def countText():
    global count
    global div
    test = getSpacedHexFromString(str(count))
    text2 = pm.setAttr("%s.textInput" % div,test)
    count += 1

def getInfo():
    sel = pm.selected()[len(pm.selected())-1]
    selShape = sel.getShape()
    pm.createNode( 'curveInfo' )
    pm.connectAttr( "%s.worldSpace" % selShape,"%s.inputCurve" % 'curveInfo1' )  
    i=1
    # cv = [pm.getAttr("%s.cv[%d]" % (selShape,i))]
    cv = [pm.getAttr("%s.cv[%d]" % (selShape,i))]
    # knot = [pm.getAttr("%s.knot[%d]" %('curveInfo1',i))]
    # while( not (pm.getAttr("%s.cv[%d]" % (selShape,i)) == pm.getAttr("%s.cv[%d]" % (selShape,i-1)))):
    #     cvp = (pm.getAttr("%s.cv[%d]" % (selShape,i)))
    #     cv.append(cvp)
    #     print '中身はなんじゃらほい',cvp
    #     i = i+1
    # cv.append(pm.getAttr("%s.cv[%d]" % (selShape,i)))
    i=1

    # while( not (pm.getAttr("%s.knot[%d]" % ('curveInfo1',i)) == pm.getAttr("%s.knot[%d]" % ('curveInfo1',i-1)))):
    #     knotp = (pm.getAttr("%s.knot[%d]" % ('curveInfo1',i)))
    #     knot.append(knotp)
    #     print '中身はなんじゃらほい',knotp
    #     i = i+1

    for i in range(0,9):
        cvp = (pm.getAttr("%s.cv[%d]" % (selShape,i)))
        cv.append(cvp)
        print '中身はなんじゃらほい',cvp
    pm.curve(name='test',d=pm.getAttr("%s.degree" % selShape),p=cv,k=[])
    print selShape
    print pm.getAttr("%s.degree" % selShape)
    print pm.getAttr("%s.cv[1]" % selShape)
    print pm.getAttr("%s.cv[2]" % selShape)
    print pm.getAttr( "%s.cp[*]" % 'curveInfo1' )




with pm.window(title='イージースムース') as smooth:
    with pm.columnLayout(adjustableColumn =True): #columnLayout:縦方向に要素を配置する　adjustableColumn: trueでUI横幅一杯に伸縮する
        with pm.horizontalLayout():
              pm.button( label='div作成' , command='print connectSmoothAttr(), "ミラー" ',bgc=[0.35,0.35,0.35])
              pm.button( label='カーブ情報取得' , command='print getCurve() ',bgc=[0.35,0.35,0.35])        
              pm.button( label='カーブ情報2' , command='print generateCurve() ',bgc=[0.35,0.35,0.35])        
        with pm.horizontalLayout():
              pm.button( label='カーブ生成' , command='print createcurve(), "ミラー" ',bgc=[0.35,0.35,0.35])
              pm.button( label='カウントテスト' , command='print countText(), "ミラー" ',bgc=[0.35,0.35,0.35])
              pm.button( label='おっす！' , command='print setText("mirror"), "ミラー" ',bgc=[0.35,0.35,0.35])
       
        with pm.horizontalLayout():
              pm.button( label='閉じる' , command='print objMirror.delete(), "閉じる" ',bgc=[0.35,0.35,0.35])